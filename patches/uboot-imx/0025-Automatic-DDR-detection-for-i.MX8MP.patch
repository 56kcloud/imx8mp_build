From f51b1230afc76aaf549f4e56484589f01d1b740b Mon Sep 17 00:00:00 2001
From: Alvaro Karsz <alvaro.karsz@solid-run.com>
Date: Tue, 23 May 2023 15:51:28 +0300
Subject: [PATCH] Automatic DDR detection for i.MX8MP

This patch adds the ability to detect the DDR in boot time and select
the correct training parameters.

The code was testes with all the possible DDRs:
4G Samsung, 3G Micron, 2G Samsung, 1G Samsung and 1G Micron.

The idea is to detect the DDR based on LPDDR4 registers
(MR5, MR6, MR7 and MR8).

Expected MR* values when training the DDR with 3G Micron parameters:

		MR5	|	M6	|	MR7	|	MR8
Samsung 1G   ************** TRAINING FAILURE ********************
Micron 1G    ************** TRAINING FAILURE ********************
Samsung 2G   ************** TRAINING FAILURE ********************
Micron 3G    0xFF		0x4		0x1		0xC
Samsung 4G   0x1		0x6		0x10		0x10

Expected MR* values when training the DDR with 1G Samsung/Micron parameters:

		MR5	|	M6	|	MR7	|	MR8
Samsung 1G      0x1		0x6		0x0		0x8
Micron 1G   	0xFF		0x3		0x0		0x8
Samsung 2G   	0x1		0x6		0x10		0x10
Micron 3G    	0xFF		0x4		0x1		0xC
Samsung 4G   ****************** UNSTABLE ************************

The algorithm to detect the DDR works as follow:

Train the DDR with Micron 3G parameters.
If succeeds, check MR* and decide if this is a 3G Micron or 4G Samsung.
If fails, Train the DDR with Samsung/Micron 1G parameters.
Then check MR* and decide if this is a 2G Samsung or 1G Micron/Samsung.

If the function to identify the DDR fails, it tries then the generic
approach:

Try 4G Samsung parameters
Try 3G Micron parameters
Try 2G Samsung parameters
Try 1G Micron/Samsung parameters

Notes regarding the generic approach:
* Training with 4G Samsung parameters will work for 3G Micron DDR as well,
  so, in order to check if this is a 3G or 4G DDR, we write to an offset
  in the SDRAM2 region, if this is a 3G chip, we won't be able to modify
  the content.

* Training with 2G Samsung parameters will work for 1G DDR as well,
  so, in order to check if this is a 1G or 2G DDR, we write to an offset
  that overflows 1G, and see if the data in "mirrored" to another
  offset.

If the generic approach fails, the board will hang.

In addition to the described functionality, this patch also adds:
* A fix the the function used to read lpddr4 MR registers, without this
  fix, the output is always 0.
* New functionality to identify the total amount of memory in SDRAM_2
  (in u-boot, not SPL).

Please note that defining DEBUG in board/solidrun/imx8mp_solidrun/spl.c
will add prints to the read MR* values during detection.

Please note that defining PRINT_DDR_TABLES in board/solidrun/imx8mp_solidrun/spl.c
will try all training parameters and print the MR* values for every
parameter set, for example:

****************************************
************** DDR Tables **************
****************************************
(Please print the tables multiple times
to determine if the values are stable).

Size    MR5     MR6     MR7     MR8
4G      ********** Failed **********
3G      ********** Failed **********
2G      0xff    0x3     0x0     0x8
1G      0xff    0x3     0x0     0x8

****************************************
************ DDR Tables End ************
****************************************

Future compability:
------------------

If a new DDR option is added, this code may be need modifications.

New DDR without new training parameters:
---------------------------------------

If the MR* values are different:
  If the new DDR works with existing parameters, the spl_identify_ddr
  function will fail, but the spl_generic_ddr_init function will succeed.
  There is nothing wrong with that, but fixing the spl_generic_ddr_init
  function in this case is easy and will result in a faster boot.
  Just add another condition with the relevant MR* values to the
  function.

If the MR* values are the same as another chip with the same volume:
  Nothing to do here, everything will work fine, maybe some printf
  should be adjusted.

If the MR* values are the same as another chip with different volume:
  We have no way to differentiate between the 2, a new approach is
  needed. Maybe check the MR* values with all DDR parameters sets?
  (define PRINT_DDR_TABLES may be helpful)

New DDR with new training parameters:
---------------------------------------
We'll need to modify spl_identify_ddr and spl_generic_ddr_init.
Modifiying spl_print_ddr_tables may help for debugging purposes.

New DDR with >= 4G:
--------------------------
The board_phys_sdram2_size function in:
board/solidrun/imx8mp_solidrun/imx8mp_solidrun.c
may need modifications.

If size is > 4G, update PHYS_SDRAM_2_SIZE.

Signed-off-by: Alvaro Karsz <alvaro.karsz@solid-run.com>
---
 arch/arm/include/asm/arch-imx8m/ddr.h         |   2 +-
 arch/arm/mach-imx/imx8m/soc.c                 |  41 ++-
 board/solidrun/imx8mp_solidrun/Makefile       |   2 +-
 .../imx8mp_solidrun/imx8mp_solidrun.c         |  61 ++++
 ...g.c => lpddr4_timing_1gb_samsung_micron.c} |   3 +-
 board/solidrun/imx8mp_solidrun/spl.c          | 344 ++++++++++++++----
 drivers/ddr/imx/imx8m/ddrphy_utils.c          |   9 +-
 include/configs/imx8mp_solidrun.h             |   7 +-
 8 files changed, 392 insertions(+), 77 deletions(-)
 rename board/solidrun/imx8mp_solidrun/{lpddr4_timing_1gb_samsung.c => lpddr4_timing_1gb_samsung_micron.c} (99%)

diff --git a/arch/arm/include/asm/arch-imx8m/ddr.h b/arch/arm/include/asm/arch-imx8m/ddr.h
index 0f1e832c..2fc07919 100644
--- a/arch/arm/include/asm/arch-imx8m/ddr.h
+++ b/arch/arm/include/asm/arch-imx8m/ddr.h
@@ -720,7 +720,7 @@ void ddrc_inline_ecc_scrub_end(unsigned int start_address,
 int wait_ddrphy_training_complete(void);
 void ddrphy_init_set_dfi_clk(unsigned int drate);
 void ddrphy_init_read_msg_block(enum fw_type type);
-
+unsigned int lpddr4_mr_read(unsigned int mr_rank, unsigned int mr_addr);
 void update_umctl2_rank_space_setting(unsigned int pstat_num);
 void get_trained_CDD(unsigned int fsp);
 
diff --git a/arch/arm/mach-imx/imx8m/soc.c b/arch/arm/mach-imx/imx8m/soc.c
index c55ea8df..6a4da585 100644
--- a/arch/arm/mach-imx/imx8m/soc.c
+++ b/arch/arm/mach-imx/imx8m/soc.c
@@ -206,6 +206,19 @@ __weak int board_phys_sdram_size(phys_size_t *size)
 	return 0;
 }
 
+__weak int board_phys_sdram2_size(phys_size_t *size)
+{
+	if (!size)
+		return -EINVAL;
+
+#ifdef PHYS_SDRAM_2_SIZE
+	*size = PHYS_SDRAM_2_SIZE;
+#else
+	*size = 0;
+#endif
+	return 0;
+}
+
 int dram_init(void)
 {
 	phys_size_t sdram_size;
@@ -221,10 +234,11 @@ int dram_init(void)
 	else
 		gd->ram_size = sdram_size;
 
-#ifdef PHYS_SDRAM_2_SIZE
-	gd->ram_size += PHYS_SDRAM_2_SIZE;
-#endif
+	ret = board_phys_sdram2_size(&sdram_size);
+	if (ret)
+		return ret;
 
+	gd->ram_size += sdram_size;
 	return 0;
 }
 
@@ -263,8 +277,13 @@ int dram_init_banksize(void)
 		puts("CONFIG_NR_DRAM_BANKS is not enough for SDRAM_2\n");
 		return -1;
 	}
+
+	ret = board_phys_sdram2_size(&sdram_size);
+	if(ret)
+		return ret;
+
 	gd->bd->bi_dram[bank].start = PHYS_SDRAM_2;
-	gd->bd->bi_dram[bank].size = PHYS_SDRAM_2_SIZE;
+	gd->bd->bi_dram[bank].size = sdram_size;
 #endif
 
 	return 0;
@@ -272,15 +291,19 @@ int dram_init_banksize(void)
 
 phys_size_t get_effective_memsize(void)
 {
+	phys_size_t sdram_size;
+	int ret;
+
 	/* return the first bank as effective memory */
 	if (rom_pointer[1])
 		return ((phys_addr_t)rom_pointer[0] - PHYS_SDRAM);
 
-#ifdef PHYS_SDRAM_2_SIZE
-	return gd->ram_size - PHYS_SDRAM_2_SIZE;
-#else
-	return gd->ram_size;
-#endif
+	ret = board_phys_sdram2_size(&sdram_size);
+	if (!ret)
+		return gd->ram_size - sdram_size;
+	else
+		return gd->ram_size;
+
 }
 
 static u32 get_cpu_variant_type(u32 type)
diff --git a/board/solidrun/imx8mp_solidrun/Makefile b/board/solidrun/imx8mp_solidrun/Makefile
index 649c0d5c..543c61dc 100644
--- a/board/solidrun/imx8mp_solidrun/Makefile
+++ b/board/solidrun/imx8mp_solidrun/Makefile
@@ -8,5 +8,5 @@ obj-y += imx8mp_solidrun.o mmc.o
 
 ifdef CONFIG_SPL_BUILD
 obj-y += spl.o
-obj-$(CONFIG_IMX8M_LPDDR4) += lpddr4_timing_4gb_samsung.o lpddr4_timing_3gb_micron.o lpddr4_timing_2gb_samsung.o lpddr4_timing_1gb_samsung.o
+obj-$(CONFIG_IMX8M_LPDDR4) += lpddr4_timing_4gb_samsung.o lpddr4_timing_3gb_micron.o lpddr4_timing_2gb_samsung.o lpddr4_timing_1gb_samsung_micron.o
 endif
diff --git a/board/solidrun/imx8mp_solidrun/imx8mp_solidrun.c b/board/solidrun/imx8mp_solidrun/imx8mp_solidrun.c
index 7aac95d9..5561cc44 100644
--- a/board/solidrun/imx8mp_solidrun/imx8mp_solidrun.c
+++ b/board/solidrun/imx8mp_solidrun/imx8mp_solidrun.c
@@ -22,6 +22,7 @@
 #include <usb.h>
 #include <dwc3-uboot.h>
 #include <asm/mach-imx/sys_proto.h>
+#include <asm/arch/ddr.h>
 
 #include <malloc.h>
 #include <fsl_esdhc.h>
@@ -104,6 +105,66 @@ int board_phys_sdram_size(phys_size_t *size)
 	return 0;
 }
 
+__weak unsigned int lpddr4_mr_read(unsigned int mr_rank, unsigned int mr_addr)
+{
+	unsigned int tmp;
+
+	reg32_write(DRC_PERF_MON_MRR0_DAT(0), 0x1);
+
+	do {
+		tmp = reg32_read(DDRC_MRSTAT(0));
+	} while (tmp & 0x1);
+
+	reg32_write(DDRC_MRCTRL0(0), (mr_rank << 4) | 0x1);
+	reg32_write(DDRC_MRCTRL1(0), (mr_addr << 8));
+	reg32setbit(DDRC_MRCTRL0(0), 31);
+	do {
+		tmp = reg32_read(DRC_PERF_MON_MRR0_DAT(0));
+	} while ((tmp & 0x8) == 0);
+	tmp = reg32_read(DRC_PERF_MON_MRR1_DAT(0));
+	reg32_write(DRC_PERF_MON_MRR0_DAT(0), 0x4);
+
+	while (tmp) { //try to find a significant byte in the word
+		if (tmp & 0xff) {
+			tmp &= 0xff;
+			break;
+		}
+		tmp >>= 8;
+	}
+
+	return tmp;
+}
+
+int board_phys_sdram2_size(phys_size_t *size)
+{
+	phys_size_t output = 0;
+	unsigned int mr5;
+	int ret;
+
+	ret = board_phys_sdram_size(size);
+	if (ret)
+		return ret;
+
+	/* The only 4G configuration is a Samsung chip.
+	 * If SDRAM1 size is 3G, there are 2 options:
+	 *
+	 * (*) A 3G Micron chip.
+	 * (*) A 4G Samsung chip.
+	 *
+	 */
+
+	if (*size == 3*ONE_GB) {
+		/* Read LPDDr MR5 register */
+		mr5 = lpddr4_mr_read(0xF, 0x5);
+		if (mr5 == LPDDR4_SAMSUNG_MANID)
+			output = ONE_GB;
+	}
+
+	*size = output;
+	return 0;
+}
+
+
 int board_early_init_f(void)
 {
 	struct wdog_regs *wdog = (struct wdog_regs *)WDOG1_BASE_ADDR;
diff --git a/board/solidrun/imx8mp_solidrun/lpddr4_timing_1gb_samsung.c b/board/solidrun/imx8mp_solidrun/lpddr4_timing_1gb_samsung_micron.c
similarity index 99%
rename from board/solidrun/imx8mp_solidrun/lpddr4_timing_1gb_samsung.c
rename to board/solidrun/imx8mp_solidrun/lpddr4_timing_1gb_samsung_micron.c
index 24bf5dcb..c923c87d 100644
--- a/board/solidrun/imx8mp_solidrun/lpddr4_timing_1gb_samsung.c
+++ b/board/solidrun/imx8mp_solidrun/lpddr4_timing_1gb_samsung_micron.c
@@ -1837,7 +1837,7 @@ static struct dram_fsp_msg ddr_dram_fsp_msg[] = {
 };
 
 /* ddr timing config params */
-struct dram_timing_info dram_timing_1gb_samsung = {
+struct dram_timing_info dram_timing_1gb_samsung_micron = {
 	.ddrc_cfg = ddr_ddrc_cfg,
 	.ddrc_cfg_num = ARRAY_SIZE(ddr_ddrc_cfg),
 	.ddrphy_cfg = ddr_ddrphy_cfg,
@@ -1850,4 +1850,3 @@ struct dram_timing_info dram_timing_1gb_samsung = {
 	.ddrphy_pie_num = ARRAY_SIZE(ddr_phy_pie),
 	.fsp_table = { 4000, 400, 100, },
 };
-
diff --git a/board/solidrun/imx8mp_solidrun/spl.c b/board/solidrun/imx8mp_solidrun/spl.c
index 10adc934..cb78130f 100644
--- a/board/solidrun/imx8mp_solidrun/spl.c
+++ b/board/solidrun/imx8mp_solidrun/spl.c
@@ -3,6 +3,8 @@
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
+//#define PRINT_DDR_TABLES
+//#define DEBUG
 
 #include <common.h>
 #include <cpu_func.h>
@@ -25,12 +27,12 @@
 #include <mmc.h>
 #include <asm/arch/ddr.h>
 
-#define ONE_GB 0x40000000ULL
 DECLARE_GLOBAL_DATA_PTR;
 
+extern struct dram_timing_info dram_timing_4gb_samsung;
 extern struct dram_timing_info dram_timing_3gb_micron;
-extern struct dram_timing_info dram_timing_1gb_samsung;
 extern struct dram_timing_info dram_timing_2gb_samsung;
+extern struct dram_timing_info dram_timing_1gb_samsung_micron;
 
 int spl_board_boot_device(enum boot_device boot_dev_spl)
 {
@@ -58,74 +60,294 @@ int spl_board_boot_device(enum boot_device boot_dev_spl)
 #endif
 }
 
-int check_mirror_ddr(unsigned int addr_1, unsigned int addr_2)
+#ifdef PRINT_DDR_TABLES
+static void spl_print_ddr_tables(void)
 {
-	/* return 1 if mirror detected between addr_1 & addre_2, else return 0*/
-	int retrain_tmp;
-	unsigned int save1, save2, mirror;
-	volatile unsigned int *ptr;
-
-	retrain_tmp = 0;
-
-	ptr = (volatile unsigned int *)CONFIG_SYS_SDRAM_BASE;
-	save1 = ptr[addr_1];
-	save2 = ptr[addr_2];
-	ptr[addr_2] = save1 << 2;
-	ptr[addr_1] = ~save1;
-	mirror = ptr[addr_2];
-	if (mirror == ~save1) {
-		printf ("Mirror detected\n");
-		retrain_tmp = 1;
+	struct dram_timing_info *confs[4] = {&dram_timing_4gb_samsung, &dram_timing_3gb_micron,
+					     &dram_timing_2gb_samsung, &dram_timing_1gb_samsung_micron};
+	int ret, i;
+	unsigned int mr5[4];
+	unsigned int mr6[4];
+	unsigned int mr7[4];
+	unsigned int mr8[4];
+	bool is_valid[4];
+
+	/* Collect data */
+	for (i = 0; i < 4; i++) {
+		ret = ddr_init(confs[i]);
+		if (ret) {
+			is_valid[i] = false;
+		} else {
+			is_valid[i] = true;
+			mr5[i] = lpddr4_mr_read(0xFF, 0x5);
+			mr6[i] = lpddr4_mr_read(0xFF, 0x6);
+			mr7[i] = lpddr4_mr_read(0xFF, 0x7);
+			mr8[i] = lpddr4_mr_read(0xFF, 0x8);
+		}
 	}
-	ptr[addr_1] = save1;
-	ptr[addr_2] = save2;
 
-	// Check if mirror have detected
-	if (retrain_tmp == 1)
-		return 1;
+	/* Now print table */
+
+	printf("\n\n\n");
+	printf("****************************************\n");
+	printf("************** DDR Tables **************\n");
+	printf("****************************************\n");
+	printf("(Please print the tables multiple times\nto determine if the values are stable).\n");
+	printf("\n");
+	printf("Size\tMR5\tMR6\tMR7\tMR8\n");
+
+	for (i = 0; i < 4; i++) {
+		if (!is_valid[i])
+			printf("%uG\t********** Failed **********\n", 4 - i);
+		else
+			printf("%uG\t0x%x\t0x%x\t0x%x\t0x%x\n", 4 - i, mr5[i], mr6[i], mr7[i], mr8[i]);
+	}
+	printf("\n");
+	printf("****************************************\n");
+	printf("************ DDR Tables End ************\n");
+	printf("****************************************\n");
+	printf("\n\n\n");
+}
+#endif //PRINT_DDR_TABLES
 
-	return 0;
+/* MUST be called after DDR training with 4G parameters! */
+static bool spl_dram_is_3G(void)
+{
+	volatile uint32_t *base;
+	uint32_t backup;
+	bool ret = false;
+
+	/* SDRAM 2 starts after 3G.
+	 * We write 512M after the 3G offset.
+	 * If the value is not written, this is a 3G configuration.
+	 */
+	base = (volatile uint32_t *)(PHYS_SDRAM_2 + SZ_512M);
+
+	/* Backup value */
+	backup = *base;
+
+	/* Write something */
+	*base = ~backup;
+	/* Read back */
+	if (*base != ~backup)
+		ret = true;
+
+	*base = backup;
+	return ret;
 }
 
-void spl_dram_init(void)
+/* MUST be called after DDR training with 2G parameters! */
+static bool spl_dram_is_1G(void)
 {
-	int ret, retrain_1gb, retrain_2gb;
+	volatile uint32_t *base1, *base2;
+	volatile uint32_t tmp;
+	uint32_t backup1, backup2;
+	bool ret = false;
+
+	/* The idea is to write a value in offset 1G and see if it is
+	 * written in offset 0 as well
+	 */
+	base1 = (volatile uint32_t *)CONFIG_SYS_SDRAM_BASE;
+	base2 = (volatile uint32_t *)((uint64_t)CONFIG_SYS_SDRAM_BASE + SZ_1G);
+
+	backup1 = *base1;
+	backup2 = *base2;
+
+	*base2 = 0xAAAAAAAA;
+	*base1 = 0x55555555;
+
+	tmp = *base2;
+	if (tmp == 0x55555555)
+		ret = true;
 
-	printf ("Training for 3GByte Mimcron\n");
+	*base1 = backup1;
+	*base2 = backup2;
+
+	return ret;
+}
+
+static bool spl_generic_ddr_init(void)
+{
+	int ret;
+	bool output = true;
+
+	printf("Initialize the DDR with the generic approach\n");
+
+	/* Try 4G Samsung.
+	 * Will work with: 3G Micron as well.
+	 */
+	ret = ddr_init(&dram_timing_4gb_samsung);
+	if (!ret) {
+		if (!spl_dram_is_3G()) {
+			printf("DDR 4G Samsung identified!\n");
+			goto exit;
+		}
+	}
+
+	/* Try 3G Micron.
+	 * Will work with: 4G Samsung, but since we already tested it,
+	 * it's not relevant
+	 */
 	ret = ddr_init(&dram_timing_3gb_micron);
-	if (ret == 0) {
-			// Check Mirror for 1GB
-			retrain_1gb = check_mirror_ddr(0, ONE_GB/4);
-			if (retrain_1gb == 1)
-			{
-				printf ("Re-training for 1GByte Samsung (3->1)\n");
-				ret = ddr_init(&dram_timing_1gb_samsung);
-				return;
-			}
-			// Check Mirror for 2GB
-			retrain_2gb = check_mirror_ddr(0, 2*ONE_GB/4);
-			if (retrain_2gb == 1)
-			{
-				printf ("Re-training for 2GByte Samsung (3->2)\n");
-				ret = ddr_init(&dram_timing_2gb_samsung);
-				return;
-			}
-	}	else {
-			printf ("Re-training for 2GByte Samsung\n");
-			ret = ddr_init(&dram_timing_2gb_samsung);
-			if (ret == 0) {
-					// Check Mirror for 1GB
-					retrain_1gb = check_mirror_ddr(0, ONE_GB/4);
-					if (retrain_1gb == 1) {
-						printf ("Re-training for 1GByte Samsung (2->1)\n");
-						ret = ddr_init(&dram_timing_1gb_samsung);
-						return;
-					}
-			} else {
-					printf ("Re-training for 1GByte Samsung(1)\n");
-					ddr_init(&dram_timing_1gb_samsung);
-					return;
-			}
+	if (!ret) {
+		printf("DDR 3G Micron identified!\n");
+		goto exit;
+	}
+
+	/* Try 2G Samsung.
+	 * Will work with: 1G Samsung as well.
+	 */
+	ret = ddr_init(&dram_timing_2gb_samsung);
+	if (!ret) {
+		if (!spl_dram_is_1G()) {
+			printf("DDR 2G Samsung identified!\n");
+			goto exit;
+		}
+	}
+
+	/* Try 1G Samsung/Micron.
+	 * If fails, we give up...
+	 */
+	ret = ddr_init(&dram_timing_1gb_samsung_micron);
+	if (ret) {
+		printf("Failed to initialize the DDR with the generic approach, giving up...\n");
+		output = false;
+	} else {
+		printf("DDR 1G Samsung/Micron identified!\n");
+	}
+
+exit:
+	return output;
+}
+
+/* Function used to identify the DDR.
+ * Function returns the timing parameters to use for DDR training, or NULL if failed
+ * to identify the DDR.
+ *
+ * In order to read the DDR values, the function will train the DDR with
+ * default parameters.
+ * Those parameters may be the same parameters needed to train the DDR.
+ * In this case, this function will set @needs_training to false, indicating that
+ * there is no need to train the DDR again.
+ * Caller can ignore this argument without harm (argument can be NULL).
+ */
+static struct dram_timing_info *spl_identify_ddr(bool *needs_training)
+{
+	int ret;
+	unsigned int mr5, mr6, mr7, mr8;
+	bool tmp;
+
+	/*                    Values for 3G Micron training
+	 *
+	 *		MR5	|	M6	|	MR7	|	MR8
+	 * Samsung 1G   ************** TRAINING FAILURE ********************
+	 * Micron 1G    ************** TRAINING FAILURE ********************
+	 * Samsung 2G   ************** TRAINING FAILURE ********************
+	 * Micron 3G    255		4		1		12
+	 * Samsung 4G   1		6		16		16
+	 *
+	 *   		      Values for 1G Samsung/Micron training
+	 *
+	 *		MR5	|	M6	|	MR7	|	MR8
+	 * Samsung 1G   1               6               0               8
+	 * Micron 1G    255		3		0		8
+	 * Samsung 2G   1		6		16		16
+	 * Micron 3G    255		4		1		12
+	 * Samsung 4G   ****************** UNSTABLE ************************
+	 *
+	 * Algorithm:
+	 * DDR training with 3G Micron, if succeeds, check if this is a 3G Micron,
+	 * 4G Samsung, or unknown.
+	 * If fails, DDR training with 1G Samsung/Micron, check if this is a 2G Samsung,
+	 * 1G Samsung, 1G Micron or unknown.
+	 */
+
+	/* Init the @needs_training argument */
+	if (!needs_training)
+		needs_training = &tmp;
+	*needs_training = true;
+
+	/* Training with 3G Micron */
+	if (!ddr_init(&dram_timing_3gb_micron)) {
+		/* Training with 3G Micron succedded */
+		mr5 = lpddr4_mr_read(0xF, 0x5);
+		mr6 = lpddr4_mr_read(0xF, 0x6);
+		mr7 = lpddr4_mr_read(0xF, 0x7);
+		mr8 = lpddr4_mr_read(0xF, 0x8);
+
+		debug("MR5=0x%x, MR6=0x%x, MR7=0x%x, MR8=0x%x\n", mr5, mr6, mr7, mr8);
+
+		if (mr5 == 0xFF && mr6 == 0x4 && mr7 == 0x1 && mr8 == 0xC) {
+			printf("DDR 3G Micron identified!\n");
+			*needs_training = false;
+			return &dram_timing_3gb_micron;
+		} else if (mr5 == 0x1 && mr6 == 0x6 && mr7 == 0x10 && mr8 == 0x10) {
+			printf("DDR 4G Samsung identified!\n");
+			return &dram_timing_4gb_samsung;
+		} else {
+			goto err;
+		}
+	} else {
+		/* Training with 3G Micron failed
+		 * DDR training with 1G Samsung/Micron
+		 */
+		ret = ddr_init(&dram_timing_1gb_samsung_micron);
+		if (ret)
+			goto err;
+
+		mr5 = lpddr4_mr_read(0xF, 0x5);
+		mr6 = lpddr4_mr_read(0xF, 0x6);
+		mr7 = lpddr4_mr_read(0xF, 0x7);
+		mr8 = lpddr4_mr_read(0xF, 0x8);
+
+		debug("MR5=0x%x, MR6=0x%x, MR7=0x%x, MR8=0x%x\n", mr5, mr6, mr7, mr8);
+
+		if (mr5 == 0x1 && mr6 == 0x6 && mr7 == 0x0 && mr8 == 0x8) {
+			printf("DDR 1G Samsung identified!\n");
+			*needs_training = false;
+			return &dram_timing_1gb_samsung_micron;
+		} else if (mr5 == 0xFF && mr6 == 0x3 && mr7 == 0x0 && mr8 == 0x8) {
+			printf("DDR 1G Micron identified!\n");
+			*needs_training = false;
+			return &dram_timing_1gb_samsung_micron;
+		} else if (mr5 == 0x1 && mr6 == 0x6 && mr7 == 0x10 && mr8 == 0x10) {
+			printf("DDR 2G Samsung identified!\n");
+			return &dram_timing_2gb_samsung;
+		} else {
+			goto err;
+		}
+	}
+
+err:
+	printf("Could not identify DDR!\n");
+	return NULL;
+}
+
+static void spl_dram_init(void)
+{
+	struct dram_timing_info *dram_info;
+	int ret = -1;
+	bool need_training;
+
+#ifdef PRINT_DDR_TABLES
+	spl_print_ddr_tables();
+#endif
+	dram_info = spl_identify_ddr(&need_training);
+	if (dram_info) {
+		/* DDR was identified, do we need to train the DDR? */
+		if (need_training)
+			ret = ddr_init(dram_info);
+		else
+			ret = 0;
+	}
+
+	/* If we failed to identify the DDR, or the parameters returned from
+	 * spl_identify_ddr caused in DDR training failure - fall back to a
+	 * generic way to train the DDR.
+	 */
+	if (ret == -1) {
+		if (!spl_generic_ddr_init())
+			hang(); //Could not init the DDR - nothing we can do..
 	}
 }
 
diff --git a/drivers/ddr/imx/imx8m/ddrphy_utils.c b/drivers/ddr/imx/imx8m/ddrphy_utils.c
index 187c38c4..b7562667 100644
--- a/drivers/ddr/imx/imx8m/ddrphy_utils.c
+++ b/drivers/ddr/imx/imx8m/ddrphy_utils.c
@@ -193,9 +193,16 @@ unsigned int lpddr4_mr_read(unsigned int mr_rank, unsigned int mr_addr)
 		tmp = reg32_read(DRC_PERF_MON_MRR0_DAT(0));
 	} while ((tmp & 0x8) == 0);
 	tmp = reg32_read(DRC_PERF_MON_MRR1_DAT(0));
-	tmp = tmp & 0xff;
 	reg32_write(DRC_PERF_MON_MRR0_DAT(0), 0x4);
 
+	while (tmp) { //try to find a significant byte in the word
+		if (tmp & 0xff) {
+			tmp &= 0xff;
+			break;
+		}
+		tmp >>= 8;
+	}
+
 	return tmp;
 }
 
diff --git a/include/configs/imx8mp_solidrun.h b/include/configs/imx8mp_solidrun.h
index 98e939a4..e7ff0625 100644
--- a/include/configs/imx8mp_solidrun.h
+++ b/include/configs/imx8mp_solidrun.h
@@ -181,8 +181,11 @@
 #define CONFIG_SYS_SDRAM_BASE		0x40000000
 #define PHYS_SDRAM			0x40000000
 #define PHYS_SDRAM_SIZE			0xC0000000	/* 3 GB */
-/*#define PHYS_SDRAM_2			0x100000000*/
-/*#define PHYS_SDRAM_2_SIZE		0xC0000000*/	/* 3 GB */
+#define PHYS_SDRAM_2			0x100000000
+#define PHYS_SDRAM_2_SIZE		0x40000000	/* 1 GB */
+
+/* Some general LPDDR4 macros */
+#define LPDDR4_SAMSUNG_MANID		0x1
 
 #define CONFIG_SYS_MEMTEST_START	PHYS_SDRAM
 #define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + \
-- 
2.34.1

